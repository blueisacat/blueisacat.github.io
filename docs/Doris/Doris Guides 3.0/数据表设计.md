---
layout: default
title: 数据表设计
parent: Doris Guides 3.0
grand_parent: Doris
nav_order: 1
---

# 1 概述
## 1.1 创建表
用户可以使用 `CREATE TABLE` 语句在 Doris 中创建表。 还可以使用 `LIKE` 或 `AS` 条件语句复制另一个表的结构。

## 1.2 表名
在 Doris 中，表名默认区分大小写。 你可以在初始群集设置时配置 `lower_case_table_namest`，使其不区分大小写。 表名的默认最大长度为 64 字节，但你可以通过配置 `table_name_length_limit` 来更改。 不建议将此值设置过高。 有关创建表的语法，请参阅 `CREATE TABLE`。

## 1.3 表属性
在 Doris 的 `CREATE TABLE` 语句中，可以指定各种表属性。 其中，存储桶数量（buckets）、存储介质（storage_medium）、复制数量（replication_num）和冷热存储策略（storage_policy）属性适用于分区。 也就是说，一旦创建了分区，它就会有自己的属性集。 修改表属性只会影响将来创建的分区，而不会追溯到已创建的分区。 有关这些属性的更多信息，请参阅修改表属性

## 1.4 注意 
1. 数据模型无法更改，因此需要在创建表时选择合适的数据模型。 
2. 无法修改现有分区的分区数量。 您可以通过更换分区来更改存储桶的数量。 不过，您可以在动态分区下修改尚未创建的分区的数据桶数量。
3. 添加或删除 VALUE 列是一项轻量级操作，几秒钟内即可完成。 添加或删除 KEY 列或修改数据类型是一项重量级操作，完成时间取决于数据量。 在数据量较大的情况下，最好避免添加或删除 KEY 列或修改数据类型。 
4. 您可以使用分层存储将冷数据保存到硬盘或 S3 / HDFS。

# 2 数据类型

Apache Doris 支持标准 SQL 语法，使用 MySQL 网络连接协议，与 MySQL 语法协议高度兼容。 因此，在数据类型支持方面，Apache Doris 尽可能与 MySQL 相关数据类型保持一致。 

Doris 支持的数据类型列表如下：

## 2.1 数字数据类型

| 类型名称 | 存储（字节） | 描述 |
| -- | -- | -- |
| BOOLEAN | 1 | 布尔数据类型，只存储两个值： 0 表示假，1 表示真。 |
| TINYINT | 1 | 整数值，取值范围为 -128 至 127。 |
| SMALLINT | 2 | 整数值，取值范围为 -32768 至 32767。 |
| INT | 4 | 整数值，取值范围为 -2147483648 至 2147483647。 |
| BIGINT | 8 | 整数值，取值范围为 -9223372036854775808 至 9223372036854775807。 |
| LARGEINT | 16 | 整数值，取值范围为 [-2^127 + 1 至 2^127 -1]。 |
| FLOAT | 4 | 单精度浮点数，取值范围为 [-3.4 10^38 至 3.4 10^38]。 |
| DOUBLE | 8 | 双精度浮点数，取值范围为 [-1.79 10^308 至 1.79 10^308]。 |
| DECIMAL | 4/8/16 | 精确定点数，由精度（总位数）和刻度（小数点右边的位数）定义。 格式为 DECIMAL(M[,D])，其中 M 是精度，D 是刻度。 M 的范围是 [1，38]，D 的范围是 [0，精度]。 存储要求： - 0 < 精度 <= 9 时为 4 字节，- 9 < 精度 <= 18 时为 8 字节，- 18 < 精度 <= 38 时为 16 字节。 |

## 2.2 日期时间数据类型

| 类型名称 | 存储（字节） | 描述 |
| -- | -- | -- |
| DATE | 16 | DATE 包含日历年、月、日的值，支持范围为['0000-01-01', '9999-12-31']。 默认打印格式： yyyy-MM-dd'。 |
| DATETIME | 16 | 日期和时间的组合格式： datetime（[p]）。 可选参数 P 代表时间精度，取值范围为 [0,6]，最多支持 6 位小数（微秒）。 不设置时，其值为 0。支持的范围为['0000-01-01 00:00:00 [.000000]', '9999-12-31 23:59:59 [.999999]'] 。 默认打印格式： 默认打印格式：'yyyy-MM-dd HH: mm: ss. SSSSSS '. |

## 2.3 字符串数据类型

| 类型名称 | 存储（字节） | 描述 |
| -- | -- | -- |
| CHAR | M | 固定长度字符串，参数 M 指定列长度（以字符为单位）。 M 的取值范围为 1 至 255。 |
| VARCHAR | 可变长度 | 长度可变的字符串，参数 M 指定字符串的最大长度（以字符为单位）。 M 的范围是 1 到 65533。 可变长度字符串以 UTF-8 编码存储。 英文字符占 1 个字节，中文字符占 3 个字节。 |
| STRING | 可变长度 | 长度可变的字符串，默认支持 1048576 字节（1 MB），最大精度限制为 2147483643 字节（2 GB）。 字符串的大小可以通过 BE 设置 string_type_length_soft_limit_bytes 进行调整。 字符串类型只能用于值列，不能用于键列和分区桶列。 |

## 2.4 半结构化数据类型

| 类型名称 | 存储（字节） | 描述 |
| -- | -- | -- |
| ARRAY | 可变长度 | 由 T 类型元素组成的数组不能用作键列。 目前支持在具有重复和唯一模型的表中使用。 |
| MAP | 可变长度 | 由 K 和 V 类型元素组成的映射不能用作关键字列。 目前，使用重复和唯一模型的表支持这些映射。 |
| STRUCT | 可变长度 | 由多个字段组成的结构也可以理解为多个列的集合。 它不能用作键。 目前，STRUCT 只能在重复模型表中使用。 结构体中字段的名称和数量是固定的，并且始终为空。 |
| JSON | 可变长度 | 二进制 JSON 类型，以二进制 JSON 格式存储，通过 JSON 函数访问内部 JSON 字段。 默认最多支持 1048576 字节（1MB），最大可调整为 2147483643 字节（2GB）。 该限制可通过 BE 配置参数 "jsonb_type_length_soft_limit_bytes "进行修改。 |
| VARIANT | 可变长度 | VARIANT 数据类型具有动态适应性，专为 JSON 等半结构化数据而设计。 它可以存储任何 JSON 对象，并自动将 JSON 字段分割成子列，以提高存储效率和查询性能。 长度限制和配置方法与 STRING 类型相同。 不过，VARIANT 类型只能用于值列，不能用于键列或分区/桶列。 |

## 2.5 聚合数据类型

| 类型名称 | 存储（字节） | 描述 |
| -- | -- | -- |
| HLL | 可变长度 | HLL 是 HyperLogLog 的缩写，是一种模糊重复数据删除技术。 在处理大型数据集时，它的性能优于 Count Distinct。 HLL 的错误率通常在 1%左右，有时可能达到 2%。 HLL 不能用作键列，创建表时的聚合类型为 HLL_UNION。 用户无需指定长度或默认值，因为它会根据数据的聚合级别进行内部控制。 HLL 列只能通过 hll_union_agg、hll_raw_agg、hll_cardinality 和 hll_hash 等配套函数进行查询或使用。 |
| BITMAP | 可变长度 | BITMAP 类型可用于聚合表、唯一表或重复表。 - 在唯一表或重复表中使用时，BITMAP 必须用作非键列。 - 在聚合表中使用时，BITMAP 也必须作为非键列，并且在创建表时必须将聚合类型设置为 BITMAP_UNION。 用户无需指定长度或默认值，因为它是根据数据的聚合级别进行内部控制的。 BITMAP 列只能通过配套函数（如 bitmap_union_count、bitmap_union、bitmap_hash 和 bitmap_hash64）来查询或使用。 |
| QUANTILE_STATE | 可变长度 | 用于计算近似量化值的类型。 加载时，它会对具有不同值的相同键进行预聚合。 当值的数量不超过 2048 个时，它会详细记录所有数据。 当数值超过 2048 个时，它会采用 TDigest 算法对数据进行聚合（聚类），并存储聚类后的中心点。 QUANTILE_STATE 不能用作键列，在创建表时应与聚合类型 QUANTILE_UNION 搭配使用。 用户无需指定长度或默认值，因为它是根据数据的聚合级别进行内部控制的。 QUANTILE_STATE 列只能通过 QUANTILE_PERCENT、QUANTILE_UNION 和 TO_QUANTILE_STATE 等配套函数进行查询或使用。 |
| AGG_STATE | 可变长度 | 聚合函数只能与状态/合并/联合函数组合器一起使用。 AGG_STATE 不能用作键列。 创建表时，需要同时声明聚合函数的签名。 用户无需指定长度或默认值。 实际数据存储大小取决于函数的实现。 |

## 2.6 IP 类型

| 类型名称 | 存储（字节） | 描述 |
| -- | -- | -- |
| IPv4 | 4 | 它与 ipv4_* 系列函数结合使用。 |
| IPv6 | 16 | 它与 ipv6_* 系列函数结合使用。 |

您还可以使用 SHOW DATA TYPES; 语句查看 Doris 支持的所有数据类型。

# 3 表索引
## 3.1 表索引概述

数据库索引用于加速查询。 为了加速不同的查询场景，Doris 支持各种丰富的索引。

### 3.1.1 索引类型和原则
从加速查询及其原理的角度来看，Doris 索引主要分为两类：点查询索引和跳数索引。 
* 点查询索引： 常用于加速点查询，其原理是通过索引找到满足 WHERE 条件的行，并直接读取这些行。 当满足条件的行数较少时，点查询索引非常有效。 Doris 的点查询索引包括前缀索引和倒排索引。 
    * 前缀索引： Doris 根据排序键有序存储数据，每 1024 行创建一个稀疏的前缀索引。 索引中的键是当前 1024 行第一行中已排序列的值。 如果查询涉及已排序列，系统将找到相关 1024 行组的第一行，并从该行开始扫描。 
    * 倒排索引： 对于具有倒排索引的列，系统会创建一个发布列表，将每个值映射到一组行 ID。 对于相等查询，首先会从发布列表中找到行 id 集，然后直接读取这些行的数据，避免逐行扫描。 倒排索引还能加速范围过滤和全文检索。 算法更加复杂，但基本原理相似。 (注意：以前的 BITMAP 索引已被功能更强大的倒置索引取代）。 
* 跳数索引： 常用于加速分析，其原理是通过索引确定不满足 WHERE 条件的数据块，并跳过这些数据块，只读取可能满足条件的数据块，然后逐行过滤，最终得到满足条件的行。 当满足条件的行数较多时，跳数索引会更加有效。 Doris 的跳数索引包括 ZoneMap 索引、BloomFilter 索引和 NGram BloomFilter 索引。 
    * ZoneMap 索引： 自动维护每个列的统计信息，记录每个数据文件（Segment）和数据块（Page）的最大值、最小值以及是否存在 NULL 值。 对于相等查询、范围查询和 IS NULL，它可以根据最大值、最小值和是否存在 NULL 值来确定数据文件和数据块是否包含满足条件的数据。 如果不能，Doris 会跳过读取相应的文件或数据块，从而减少 IO 并加速查询。 
    * BloomFilter 索引： 将索引列的值存储在 BloomFilter 数据结构中，能以极低的存储空间快速确定某个值是否在 BloomFilter 中。 对于相等查询，如果值不在 BloomFilter 中，则可跳过相应的数据文件或数据块，从而减少 IO 并加快查询速度。 
    * NGram BloomFilter 索引： 用于加速文本 LIKE 查询。 其原理与 BloomFilter 索引类似，但不是存储原始文本值，而是对文本执行 NGram 分词，并将每个分词存储在 BloomFilter 中。 对于 LIKE 查询，LIKE 模式也使用 NGram 进行分词。 如果 BloomFilter 中没有任何分词，则表示相应的数据文件或数据块不符合 LIKE 条件，可以跳过。 
    
在上述索引中，前缀索引和 ZoneMap 索引是由 Doris 自动维护的内置索引，无需用户管理。 倒排索引、BloomFilter 索引和 NGram BloomFilter 索引则需要用户根据实际情况手动创建和管理。

* 比较不同类型索引的特点

| 类型     | 索引     |   优势   |   局限性   |
| -------- | -------- | -------- | -------- |
| 点查询索引 | 前缀索引 | 内置索引，性能最佳 | 每个表只有一个前缀索引 |
| 点查询索引 | 倒排索引 | 支持分词和关键字匹配、在任意列上建立索引、多条件组合和加速更多功能 | 索引存储空间大，与原始数据类似 |
| 跳数索引 | ZoneMap 索引 | 内置索引，索引存储空间小 | 每个表只有一个前缀索引 |
| 跳数索引 | BloomFilter 索引 | 比 ZoneMap 更精确，索引空间适中 | 支持的查询类型很少，只支持等价查询，不支持其他查询（不等价、范围、LIKE、MATCH） |
| 跳数索引 | NGram BloomFilter 索引 | 支持 LIKE 加速，索引空间适中 | 支持的查询类型很少，仅支持 LIKE 加速 |

* 用于索引加速的运算符和函数列表

| 运算符和函数 | 前缀索引 | 倒排索引 | ZoneMap 索引 | BloomFilter 索引 | NGram BloomFilter 索引 |
| -------- | -------- | -------- | -------- | -------- |-------- |
| = | YES | YES | YES | YES | NO |
| != | YES | YES | NO | NO | NO |
| IN | YES | YES | YES | YES | NO |
| NOT IN | YES | YES | NO | NO | NO |
| >, >=, <, <=, BETWEEN | YES | YES | YES | NO | NO |
| IS NULL | YES | YES | YES | NO | NO |
| IS NOT NULL | YES | YES | NO | NO | NO |
| LIKE | NO | NO | NO | NO | YES |
| MATCH, MATCH_* | NO | YES | NO | NO | NO |
| array_contains | NO | YES | NO | NO | NO |
| array_overlaps | NO | YES | NO | NO | NO |
| is_ip_address_in_range | NO | YES | NO | NO | NO |

### 3.1.2 索引设计指南
数据库表索引的设计和优化与数据分布和查询密切相关，需要根据实际情况进行测试和优化。 虽然没有 "灵丹妙药"，但 Doris 一直在努力降低使用索引的难度。 用户可以遵循以下简单指南进行索引选择和测试。 
1. 指定最常用的过滤条件作为关键字，自动创建前缀索引，因为它的过滤效果最好。 不过，每个表只能创建一个前缀索引，所以应该用于最常用的过滤条件。 
2. 对于需要过滤加速的非关键字段，首选是创建倒排索引，因为它具有广泛的适用性和多条件组合。 第二种选择包括以下两种索引： 
    1. 如果需要进行字符串 LIKE 匹配，则添加一个 NGram BloomFilter 索引。 
    2. 如果索引存储空间至关重要，则用 BloomFilter 索引取代倒置索引。 
3. 如果性能不如预期，则通过 QueryProfile 分析索引过滤的数据量和消耗的时间。 有关具体情况，请参阅每个索引的详细文档。

## 3.2 排序键和前缀索引

### 3.2.1 索引原理
Doris 存储数据的结构类似于 SSTable（Sorted String Table）。 这种结构是一种有序数据结构，可以根据一个或多个指定列进行排序和存储。 在这种数据结构中，对全部或部分排序列进行条件查询的效率非常高。

在 Aggregate、Unique 和 Duplicate 数据模型中，底层数据存储分别根据 CREATE TABLE 语句中指定的 AGGREGATE KEY、UNIQUE KEY 和 DUPLICATE KEY 下的列进行排序。 这些键被称为排序键。 有了排序键，Doris 就可以在查询过程中通过指定排序列的条件，在不扫描整个表的情况下快速定位所需数据，从而降低搜索复杂度并加快查询速度。

根据排序键，Doris 引入了前缀索引。 前缀索引是一种稀疏索引。 表中的数据根据相应的行数形成一个逻辑数据块（Data Block）。 每个逻辑数据块在前缀索引表中存储一个索引条目，索引条目的长度不超过 36 字节。 条目内容是由数据块中第一行的排序列组成的前缀。 查找前缀索引表时，它有助于确定行数据所在逻辑数据块的起始行号。 由于前缀索引相对较小，因此可以完全缓存在内存中，从而可以快速定位数据块并显著提高查询效率。

> 数据块中某一行的前 36 个字节用作该行的前缀索引。 遇到 VARCHAR 类型时，前缀索引会被直接截断。 如果第一列是 VARCHAR，即使未达到 36 字节，也会被直接截断，后续列将不包含在前缀索引中。

### 3.2.2 使用场景
前缀索引可以加快相等查询和范围查询的速度。

> 由于表的 KEY 定义是唯一的，因此一个表只能有一种前缀索引。 对于使用其他列的查询，如果不能将前缀索引作为条件，则效率可能达不到要求。 有两种解决方案： 
> * 在需要加速查询的列上创建倒排索引，因为一个表可以有多个倒排索引。 
> * 对于 DUPLICATE 表，可以通过创建相应的强一致性物化视图并调整列顺序来间接实现多前缀索引。 有关详细信息，请参阅查询加速/物化视图。

### 3.2.3 语法
定义前缀索引没有特定的语法。 创建表时，表 KEY 的前 36 个字节会自动作为前缀索引。

### 3.2.4 使用示例
假设表的排序列如下，则前缀索引为：user_id（8 字节）+ age（4 字节）+ message（前缀 20 字节）。

| 列名 | 类型 |
| - | - |
| user_id | BIGINT | 
| age | INT | 
| message | VARCHAR(100) | 
| max_dwell_time | DATETIME | 
| min_dwell_time | DATETIME | 

假设表的排序列如下，则前缀索引为 user_name（20 字节）。 即使没有达到 36 字节，也会因为遇到 VARCHAR 而直接截断，并且不包括后续列。

| 列名 | 类型 |
| - | - |
| user_name | VARCHAR(20) | 
| age | INT | 
| message | VARCHAR(100) | 
| max_dwell_time | DATETIME | 
| min_dwell_time | DATETIME | 

当我们的查询条件是前缀索引的前缀时，可以大大加快查询速度。 例如，在第一个示例中，执行以下查询：

```sql
SELECT * FROM table WHERE user_id = 1829239 AND age = 20;
```

这种查询比下面的查询要有效得多：

```sql
SELECT * FROM table WHERE age = 20;
```

因此，在创建表时选择正确的列顺序可以大大提高查询效率。

## 3.3 倒排索引
### 3.3.1 索引原理
倒排索引是信息检索领域常用的一种索引技术。 它将文本划分为单个词，并构建一个词->文档 ID 索引，以便快速搜索确定哪些文档包含特定的词。

从 2.0.0 版开始，Doris 支持倒排索引，可用于文本类型的全文检索、普通数字和日期类型的相等和范围查询，以及从海量数据中快速筛选符合条件的行。

在 Doris 实现的倒排索引中，表中的每一行对应一个文档，每一列对应文档中的一个字段。 因此，使用倒排索引，可以快速查找包含特定关键字的行，从而加快 WHERE 子句的处理速度。

与 Doris 中的其他索引不同，倒排索引在存储层使用独立文件，与数据文件一一对应，但物理存储是独立的。 这种方法允许在不重写数据文件的情况下创建和删除索引，大大减少了处理开销。

### 3.3.2 使用场景
倒排索引的应用范围很广，可以加速等值、范围和全文检索（关键字匹配、短语匹配等）。 一个表可以有多个倒排索引，查询时可以任意组合多个倒排索引的条件。

下面简要介绍一下倒排索引的功能：
1. 加速字符串类型的全文搜索
* 支持关键字搜索，包括同时匹配多个关键字 `MATCH_ALL`，以及匹配任意一个关键字 `MATCH_ANY`。
* 支持短语查询 `MATCH_PHRASE` 
    * 支持指定词之间距离 
    * 支持短语 + 前缀 `MATCH_PHRASE_PREFIX` 
* 支持分词正则表达式查询 `MATCH_REGEXP` 
* 支持英文、中文和 Unicode 分词器

2. 加速普通等式和范围查询，覆盖并取代 BITMAP 索引的功能 
* 支持对字符串、数字和日期时间类型的 =, !=, >, >=, <, <= 进行快速过滤 
* 支持对字符串、数字和日期时间数组类型的 array_contains 进行快速过滤

3. 支持全面的逻辑组合 
* 不仅支持 AND 条件的加速，还支持 OR 和 NOT 条件 
* 支持 AND、OR、NOT 多个条件的任意逻辑组合

4. 灵活高效的索引管理 
* 支持在创建表时定义倒排索引 
* 支持在现有表中添加倒排索引，增量式索引构建无需重写表中的现有数据 
* 支持从现有表中删除倒排索引，无需重写表中的现有数据

> 使用倒排索引有一些限制：
> 1. 浮点类型 FLOAT 和 DOUBLE 存在精度问题，由于精度不准确，因此不支持倒排索引。 解决方法是使用精确的 DECIMAL 类型，它支持倒排索引。
> 2. 某些复杂数据类型尚不支持倒排索引，包括 MAP、STRUCT、JSON、HLL、BITMAP、QUANTILE_STATE 和 AGG_STATE。
> 3. 启用了 Merge-on-Write 功能的 DUPLICATE 和 UNIQUE 表模型支持在任何列上建立倒排索引。 但是，未启用 Merge-on-Write 的 AGGREGATE 和 UNIQUE 模型只支持在关键字列上建立倒排索引，非关键字列不能建立倒排索引。 这是因为这两种模型需要读取所有数据进行合并，因此无法使用索引进行预过滤。
> 
> 要查看倒排索引对查询的影响，可以分析查询配置文件中的相关指标。
> * InvertedIndexFilterTime：倒排索引消耗的时间
>   * InvertedIndexSearcherOpenTime：打开倒排索引的时间
>   * InvertedIndexSearcherSearchTime：内部查询倒排索引的时间
> * RowsInvertedIndexFiltered：已被倒排索引过滤的行数，可与其他行数值进行比较，以分析 BloomFilter 索引的过滤效果。

### 3.3.3 语法
#### 3.3.3.1 创建表时定义倒排索引
在创建表语句中，COLUMN 定义之后是索引定义：
```sql
CREATE TABLE table_name
(
  column_name1 TYPE1,
  column_name2 TYPE2,
  column_name3 TYPE3,
  INDEX idx_name1(column_name1) USING INVERTED [PROPERTIES(...)] [COMMENT 'your comment'],
  INDEX idx_name2(column_name2) USING INVERTED [PROPERTIES(...)] [COMMENT 'your comment']
)
table_properties;
```

语法解释：
1. `idx_column_name(column_name)` 是必填项，`column_name` 是索引的列名，必须是之前定义的列，`idx_column_name` 是索引名，在表级别必须是唯一的，推荐命名约定：在列名前加上前缀 `idx_` 
2. 必须使用 `USING INVERTED` 来指定索引类型为倒排索引 
3. `PROPERTIES` 是可选项，用于指定倒排索引的其他属性，目前支持的属性有：

<details>
    <summary>parser</summary>
    <p>- 默认为未指定，即不进行分词</p> 
    <p>- `english`： 英文分词，适用于包含英文文本的栏目，使用空格和标点符号进行分词，性能高</p> 
    <p>- `chinese`： 中文分词，适用于主要包含中文文本的栏目，性能低于英文分词</p>
    <p>- `unicode`： Unicode 分词，适用于中英文混合和多语言混合文本。 它可以分词电子邮件前缀和后缀、IP 地址以及字符和数字混合字符串，还可以按字符分词中文。 
    <p>可使用 TOKENIZE SQL 函数验证分词结果，详见以下章节。</p>
</details>

<details>
    <summary>parser_mode</summary>
    <p>指定分词模式，`parser = chinese` 当前支持的模式有：</p> 
    <p>- fine_grained：细粒度模式，倾向于生成更短、更多的单词，例如，"武汉市长江大桥 "将被分词为 "武汉'、'武汉市'、'市长'、'长江'、'长江大桥'、'大桥'"。</p> 
    <p>- cross_grained：粗粒度模式，倾向于生成较长、较少的单词，例如，"武汉市长江大桥 "将被分词为 "武汉市"、"长江大桥"。</p>
    <p>- 默认 cross_grained </p>
</details>

<details>
    <summary>support_phrase</summary>
    <p>指定索引是否支持 MATCH_PHRASE 短语查询加速</p> 
    <p>- true：支持，但索引需要更多存储空间 </p> 
    <p>- false：不支持，存储效率更高，可使用 MATCH_ALL 查询多个关键词 </p>
    <p>- 默认为 false</p>
    <p>例如，下面的示例指定了中文分词、coarse-grained模式，并支持短语查询加速。</p>
    <pre><code>
INDEX idx_name(column_name) USING INVERTED PROPERTIES("parser" = "chinese", "parser_mode" = "coarse_grained", "support_phrase" = "true")
    </code></pre>
</details>

<details>
    <summary>char_filter</summary>
    <p>指定在分词前对文本进行预处理，通常是为了影响分词行为</p> 
    <p>char_filter_type：指定不同功能的 char_filter（目前仅支持 char_replace） </p> 
    <p>char_replace 将模式中的每个字符替换为替换字符中的一个字符。</p>
    <p>- char_filter_pattern：要替换的字符</p>
    <p>- char_filter_replacement：替换字符数组，可选，默认为空格字符</p>
    <p>例如，下面的示例将 `点` 和 `下划线` 替换为 `空格` ，从而将它们视为单词分隔符，影响标分词行为。</p>
    <pre><code>
INDEX idx_name(column_name) USING INVERTED PROPERTIES("parser" = "unicode", "char_filter_type" = "char_replace", "char_filter_pattern" = "._", "char_filter_replacement" = " ")
    </code></pre>
</details>

<details>
    <summary>ignore_above</summary>
    <p>指定非分词字符串索引的长度限制（未指定解析器）</p> 
    <p>- 长度超过 ignore_above 设置的字符串将不会被索引。 对于字符串数组，ignore_above 分别适用于每个数组元素，长度超过 ignore_above 的元素将不被索引。</p> 
    <p>- 默认为 256，单位为字节</p> 
</details>

<details>
    <summary>lower_case</summary>
    <p>是否将分词转换为小写，以便进行大小写不敏感匹配</p> 
    <p>- true: 转换为小写</p> 
    <p>- false：不转换为小写</p> 
    <p>- 从 2.0.7 和 2.1.2 版开始，默认为 true，自动转换为小写。 早期版本的默认值为 false 。</p> 
</details>

<details>
    <summary>stopwords</summary>
    <p>指定要使用的停止词列表，这将影响分词符号生成器的行为</p> 
    <p>- 默认的内置停用词列表包括 "is"、"the"、"a "等无意义的词。 在编写或查询时，分词符号生成器将忽略停用词列表中的单词。</p> 
    <p>- none： 使用空停止词表</p> 
</details>

4. `COMMENT` 是可选项，用于指定索引注释

#### 3.3.3.2 为现有表添加倒排索引
1. 添加索引
    支持 `CREATE INDEX` 和 `ALTER TABLE ADD INDEX` 语法。 参数与创建表时定义索引时使用的参数相同。

    ```sql
    -- Syntax 1
    CREATE INDEX idx_name ON table_name(column_name) USING INVERTED [PROPERTIES(...)] [COMMENT 'your comment'];
    -- Syntax 2
    ALTER TABLE table_name ADD INDEX idx_name(column_name) USING INVERTED [PROPERTIES(...)] [COMMENT 'your comment'];
    ```

2. 构建索引 
    `CREATE / ADD INDEX` 操作仅添加索引定义。 在此操作后写入的新数据将生成倒排索引，但现有数据需要使用 `BUILD INDEX` 才能触发索引：

    ```sql
    -- Syntax 1, by default, builds the index for all partitions in the table
    BUILD INDEX index_name ON table_name;
    -- Syntax 2, you can specify partitions, one or more
    BUILD INDEX index_name ON table_name PARTITIONS(partition_name1, partition_name2);
    ```

    要检查 `BUILD INDEX` 的进度，请使用 `SHOW BUILD INDEX` ：

    ```sql
    SHOW BUILD INDEX [FROM db_name];
    -- Example 1, view the progress of all BUILD INDEX tasks
    SHOW BUILD INDEX;
    -- Example 2, view the progress of BUILD INDEX tasks for a specific table
    SHOW BUILD INDEX where TableName = "table1";
    ```

    要取消 `BUILD INDEX` ，请使用 `CANCEL BUILD INDEX` ：

    ```sql
    CANCEL BUILD INDEX ON table_name;
    CANCEL BUILD INDEX ON table_name (job_id1, job_id2, ...);
    ```

> `BUILD INDEX` 会创建一个异步任务，由每个 BE 上的多个线程执行。 线程数可通过 BE 配置 `alter_index_worker_count` 设置，默认值为 3。 在 2.0.12 和 2.1.4 之前的版本中，`BUILD INDEX` 会不断重试，直到成功为止。 从这些版本开始，失败和超时机制防止了无休止的重试。 3.0（云模式）目前不支持该命令。
> 1. 如果某个 tablet 的大多数副本都无法 `BUILD INDEX`，则整个 `BUILD INDEX` 操作都会失败。
> 2. 如果时间超过 `alter_table_timeout_second`，则 `BUILD INDEX` 操作超时。
> 用户可以多次触发 `BUILD INDEX`；已成功建立的索引将不会重建。

#### 3.3.3.3 从现有表中删除倒排索引

```sql
-- Syntax 1
DROP INDEX idx_name ON table_name;
-- Syntax 2
ALTER TABLE table_name DROP INDEX idx_name;
```

> `DROP INDEX` 会删除索引定义，因此新数据将不再写入索引。 这将创建一个异步任务来执行索引删除，由每个 BE 上的多个线程执行。 可以使用 BE 参数 `alter_index_worker_count` 设置线程数，默认值为 3。

#### 3.3.3.4 使用倒排索引加速查询

```sql
-- 1. Full-text search keyword matching using MATCH_ANY and MATCH_ALL
SELECT * FROM table_name WHERE column_name MATCH_ANY | MATCH_ALL 'keyword1 ...';

-- 1.1 Rows in the content column containing keyword1
SELECT * FROM table_name WHERE content MATCH_ANY 'keyword1';

-- 1.2 Rows in the content column containing keyword1 or keyword2; you can add more keywords
SELECT * FROM table_name WHERE content MATCH_ANY 'keyword1 keyword2';

-- 1.3 Rows in the content column containing both keyword1 and keyword2; you can add more keywords
SELECT * FROM table_name WHERE content MATCH_ALL 'keyword1 keyword2';
```

```sql
-- 2. Full-text search phrase matching using MATCH_PHRASE

-- 2.1 Rows in the content column containing both keyword1 and keyword2, where keyword2 must immediately follow keyword1
-- 'keyword1 keyword2', 'wordx keyword1 keyword2', 'wordx keyword1 keyword2 wordy' all match because they contain 'keyword1 keyword2' with keyword2 immediately following keyword1
-- 'keyword1 wordx keyword2' does not match because there is a word between keyword1 and keyword2
-- 'keyword2 keyword1' does not match because the order is reversed
SELECT * FROM table_name WHERE content MATCH_PHRASE 'keyword1 keyword2';

-- 2.2 Rows in the content column containing both keyword1 and keyword2, with a slop (maximum word distance) of 3
-- 'keyword1 keyword2', 'keyword1 a keyword2', 'keyword1 a b c keyword2' all match because the slop is 0, 1, and 3 respectively, all within 3
-- 'keyword1 a b c d keyword2' does not match because the slop is 4, exceeding 3
-- 'keyword2 keyword1', 'keyword2 a keyword1', 'keyword2 a b c keyword1' also match because when slop > 0, the order of keyword1 and keyword2 is not required. To enforce the order, Doris provides a + sign after slop
SELECT * FROM table_name WHERE content MATCH_PHRASE 'keyword1 keyword2 ~3';
-- To enforce order, use a positive sign with slop; 'keyword1 a b c keyword2' matches, while 'keyword2 a b c keyword1' does not
SELECT * FROM table_name WHERE content MATCH_PHRASE 'keyword1 keyword2 ~3+';

-- 2.3 Prefix matching the last word keyword2, with a default limit of 50 prefixes (controlled by session variable inverted_index_max_expansions)
-- 'keyword1 keyword2abc' matches because keyword1 is identical and keyword2abc is a prefix of keyword2
-- 'keyword1 keyword2' also matches because keyword2 is a prefix of keyword2
-- 'keyword1 keyword3' does not match because keyword3 is not a prefix of keyword2
-- 'keyword1 keyword3abc' does not match because keyword3abc is not a prefix of keyword2
SELECT * FROM table_name WHERE content MATCH_PHRASE_PREFIX 'keyword1 keyword2';

-- 2.4 If only one word is provided, it defaults to a prefix query with a limit of 50 prefixes (controlled by session variable inverted_index_max_expansions)
SELECT * FROM table_name WHERE content MATCH_PHRASE_PREFIX 'keyword1';

-- 2.5 Regular expression matching on tokenized words, with a default limit of 50 matches (controlled by session variable inverted_index_max_expansions)
-- Similar to MATCH_PHRASE_PREFIX but with regex instead of prefix
SELECT * FROM table_name WHERE content MATCH_REGEXP 'key*';
```

```sql
-- 3. Normal equality, range, IN, and NOT IN queries using standard SQL syntax, for example:
SELECT * FROM table_name WHERE id = 123;
SELECT * FROM table_name WHERE ts > '2023-01-01 00:00:00';
SELECT * FROM table_name WHERE op_type IN ('add', 'delete');
```

#### 3.3.3.5 TOKENIZE 函数
要检查分词的实际效果或对一段文本进行分词，可以使用 `TOKENIZE` 函数进行验证。

`TOKENIZE` 函数的第一个参数是要分词的文本，第二个参数指定创建索引时使用的分词参数。

mysql> SELECT TOKENIZE('I love CHINA','"parser"="english"'); +------------------------------------------------+ | tokenize('I love CHINA', '"parser"="english"') | +------------------------------------------------+ | ["i", "love", "china"] | +------------------------------------------------+ 1 row in set (0.02 sec)

mysql> SELECT TOKENIZE('I love CHINA 我爱我的祖国','"parser"="unicode"'); +-------------------------------------------------------------------+ | tokenize('I love CHINA 我爱我的祖国', '"parser"="unicode"') | +-------------------------------------------------------------------+ | ["i", "love", "china", "我", "爱", "我", "的", "祖", "国"] | +-------------------------------------------------------------------+ 1 row in set (0.02 sec)

**使用示例**

演示使用 HackerNews 的 100 万条记录创建倒排索引、全文搜索和常规查询。 其中包括与无索引查询的简单性能比较。

**创建表**

```sql
CREATE DATABASE test_inverted_index;

USE test_inverted_index;

-- Create a table with an inverted index on the comment field
--   USING INVERTED specifies the index type as an inverted index
--   PROPERTIES("parser" = "english") specifies using the "english" tokenizer; other options include "chinese" for Chinese tokenization and "unicode" for mixed-language tokenization. If the "parser" parameter is not specified, no tokenization is applied.

CREATE TABLE hackernews_1m
(
    `id` BIGINT,
    `deleted` TINYINT,
    `type` String,
    `author` String,
    `timestamp` DateTimeV2,
    `comment` String,
    `dead` TINYINT,
    `parent` BIGINT,
    `poll` BIGINT,
    `children` Array<BIGINT>,
    `url` String,
    `score` INT,
    `title` String,
    `parts` Array<INT>,
    `descendants` INT,
    INDEX idx_comment (`comment`) USING INVERTED PROPERTIES("parser" = "english") COMMENT 'inverted index for comment'
)
DUPLICATE KEY(`id`)
DISTRIBUTED BY HASH(`id`) BUCKETS 10
PROPERTIES ("replication_num" = "1");
```

#### 3.3.3.6 数据导入
通过数据流加载导入数据

```cmd
wget https://doris-build-1308700295.cos.ap-beijing.myqcloud.com/regression/index/hacknernews_1m.csv.gz

curl --location-trusted -u root: -H "compress_type:gz" -T hacknernews_1m.csv.gz http://127.0.0.1:8030/api/test_inverted_index/hackernews_1m/_stream_load
{
    "TxnId": 2,
    "Label": "a8a3e802-2329-49e8-912b-04c800a461a6",
    "TwoPhaseCommit": "false",
    "Status": "Success",
    "Message": "OK",
    "NumberTotalRows": 1000000,
    "NumberLoadedRows": 1000000,
    "NumberFilteredRows": 0,
    "NumberUnselectedRows": 0,
    "LoadBytes": 130618406,
    "LoadTimeMs": 8988,
    "BeginTxnTimeMs": 23,
    "StreamLoadPutTimeMs": 113,
    "ReadDataTimeMs": 4788,
    "WriteDataTimeMs": 8811,
    "CommitAndPublishTimeMs": 38
}
```

使用 SQL count() 确认数据导入成功

```cmd
mysql> SELECT count() FROM hackernews_1m;
+---------+
| count() |
+---------+
| 1000000 |
+---------+
1 row in set (0.02 sec)
```

#### 3.3.3.7 查询
1. 全文搜索
* 使用 `LIKE` 对 `comment` 列中包含 "OLAP "的记录进行匹配和计数耗时 0.18 秒。

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE comment LIKE '%OLAP%';
    +---------+
    | count() |
    +---------+
    |      34 |
    +---------+
    1 row in set (0.18 sec)
    ```

* 使用基于倒排索引的 `MATCH_ANY` 全文搜索来计算 `comment` 列中包含 "OLAP "的行，耗时 0.02 秒，速度提高了 9 倍。 在更大的数据集上，性能提升将更为显著。
结果数量上的差异是由于倒排索引通过将术语转换为小写字母等过程对术语进行了规范化处理，因此 `MATCH_ANY` 产生的结果比 `LIKE` 多。

    ```shell
    mysql> SELECT count() FROM hackernews_1m WHERE comment MATCH_ANY 'OLAP';
    +---------+
    | count() |
    +---------+
    |      35 |
    +---------+
    1 row in set (0.02 sec)
    ```

* 同样，在计算 "OLTP "的出现次数时，0.07 秒对 0.01 秒。 由于缓存的作用，`LIKE` 和 `MATCH_ANY` 的速度都有所提高，但倒排索引的速度仍然提高了 7 倍。

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE comment LIKE '%OLTP%';
    +---------+
    | count() |
    +---------+
    |      48 |
    +---------+
    1 row in set (0.07 sec)

    mysql> SELECT count() FROM hackernews_1m WHERE comment MATCH_ANY 'OLTP';
    +---------+
    | count() |
    +---------+
    |      51 |
    +---------+
    1 row in set (0.01 sec)
    ```

* 计算同时出现 "OLAP "和 "OLTP "的行耗时 0.13s 对 0.01s，速度提高了 13 倍。
要要求多个术语同时出现（AND 关系），请使用 `MATCH_ALL 'keyword1 keyword2 ...'` 。

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE comment LIKE '%OLAP%' AND comment LIKE '%OLTP%';
    +---------+
    | count() |
    +---------+
    |      14 |
    +---------+
    1 row in set (0.13 sec)

    mysql> SELECT count() FROM hackernews_1m WHERE comment MATCH_ALL 'OLAP OLTP';
    +---------+
    | count() |
    +---------+
    |      15 |
    +---------+
    1 row in set (0.01 sec)
    ```

* 计算出现 "OLAP "或 "OLTP "的行耗时 0.12s 对 0.01s，速度提高了 12 倍。
要要求出现多个术语中的任意一个或多个（OR 关系），请使用 `MATCH_ANY 'keyword1 keyword2 ...'` 。

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE comment LIKE '%OLAP%' OR comment LIKE '%OLTP%';
    +---------+
    | count() |
    +---------+
    |      68 |
    +---------+
    1 row in set (0.12 sec)

    mysql> SELECT count() FROM hackernews_1m WHERE comment MATCH_ANY 'OLAP OLTP';
    +---------+
    | count() |
    +---------+
    |      71 |
    +---------+
    1 row in set (0.01 sec)
    ```

2. 标准相等和范围查询
* `DateTime` 类型列上的范围查询

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE timestamp > '2007-08-23 04:17:00';
    +---------+
    | count() |
    +---------+
    |  999081 |
    +---------+
    1 row in set (0.03 sec)
    ```

* 为 `timestamp` 列添加倒排索引

    ```cmd
    -- For date-time types, USING INVERTED does not require specifying a parser
    -- CREATE INDEX is one syntax for creating an index, another method will be shown later
    mysql> CREATE INDEX idx_timestamp ON hackernews_1m(timestamp) USING INVERTED;
    Query OK, 0 rows affected (0.03 sec)
    ```

    ```cmd
    mysql> BUILD INDEX idx_timestamp ON hackernews_1m;
    Query OK, 0 rows affected (0.01 sec)
    ```

* 检查索引创建进度 从 `FinishTime` 和 `CreateTime` 之间的差值可以看出，在时间戳列上为 100 万行建立倒排索引只用了 1 秒钟。

    ```cmd
    mysql> SHOW ALTER TABLE COLUMN;
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+
    | JobId | TableName     | CreateTime              | FinishTime              | IndexName     | IndexId | OriginIndexId | SchemaVersion | TransactionId | State    | Msg  | Progress | Timeout |
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+
    | 10030 | hackernews_1m | 2023-02-10 19:44:12.929 | 2023-02-10 19:44:13.938 | hackernews_1m | 10031   | 10008         | 1:1994690496  | 3             | FINISHED |      | NULL     | 2592000 |
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+
    1 row in set (0.00 sec)
    ```

    ```cmd
    -- If the table has no partitions, PartitionName defaults to TableName
    mysql> SHOW BUILD INDEX;
    +-------+---------------+---------------+----------------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    | JobId | TableName     | PartitionName | AlterInvertedIndexes                                     | CreateTime              | FinishTime              | TransactionId | State    | Msg  | Progress |
    +-------+---------------+---------------+----------------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    | 10191 | hackernews_1m | hackernews_1m | [ADD INDEX idx_timestamp (`timestamp`) USING INVERTED],  | 2023-06-26 15:32:33.894 | 2023-06-26 15:32:34.847 | 3             | FINISHED |      | NULL     |
    +-------+---------------+---------------+----------------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    1 row in set (0.04 sec)
    ```

* 创建索引后，范围查询将使用相同的查询语法。 Doris 会自动识别索引以进行优化。 不过，由于数据集较小，性能差异不大。

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE timestamp > '2007-08-23 04:17:00';
    +---------+
    | count() |
    +---------+
    |  999081 |
    +---------+
    1 row in set (0.01 sec)
    ```

* 使用相等匹配查询对数字列的 `parent` 执行类似操作。

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE parent = 11189;
    +---------+
    | count() |
    +---------+
    |       2 |
    +---------+
    1 row in set (0.01 sec)

    -- For numeric types, USING INVERTED does not require specifying a parser
    -- ALTER TABLE t ADD INDEX is the second syntax for creating an index
    mysql> ALTER TABLE hackernews_1m ADD INDEX idx_parent(parent) USING INVERTED;
    Query OK, 0 rows affected (0.01 sec)

    -- Execute BUILD INDEX to create the inverted index for existing data
    mysql> BUILD INDEX idx_parent ON hackernews_1m;
    Query OK, 0 rows affected (0.01 sec)

    mysql> SHOW ALTER TABLE COLUMN;
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+
    | JobId | TableName     | CreateTime              | FinishTime              | IndexName     | IndexId | OriginIndexId | SchemaVersion | TransactionId | State    | Msg  | Progress | Timeout |
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+
    | 10030 | hackernews_1m | 2023-02-10 19:44:12.929 | 2023-02-10 19:44:13.938 | hackernews_1m | 10031   | 10008         | 1:1994690496  | 3             | FINISHED |      | NULL     | 2592000 |
    | 10053 | hackernews_1m | 2023-02-10 19:49:32.893 | 2023-02-10 19:49:33.982 | hackernews_1m | 10054   | 10008         | 1:378856428   | 4             | FINISHED |      | NULL     | 2592000 |
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+

    mysql> SHOW BUILD INDEX;
    +-------+---------------+---------------+----------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    | JobId | TableName     | PartitionName | AlterInvertedIndexes                               | CreateTime              | FinishTime              | TransactionId | State    | Msg  | Progress |
    +-------+---------------+---------------+----------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    | 11005 | hackernews_1m | hackernews_1m | [ADD INDEX idx_parent (`parent`) USING INVERTED],  | 2023-06-26 16:25:10.167 | 2023-06-26 16:25:10.838 | 1002          | FINISHED |      | NULL     |
    +-------+---------------+---------------+----------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    1 row in set (0.01 sec)

    mysql> SELECT count() FROM hackernews_1m WHERE parent = 11189;
    +---------+
    | count() |
    +---------+
    |       2 |
    +---------+
    1 row in set (0.01 sec)
    ```

* 为未分词的字符串列 `author` 创建倒排索引。 等式查询也可以利用该索引来加快速度。

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE author = 'faster';
    +---------+
    | count() |
    +---------+
    |      20 |
    +---------+
    1 row in set (0.03 sec)

    -- Here, USING INVERTED is used without tokenizing the `author` column, treating it as a single term
    mysql> ALTER TABLE hackernews_1m ADD INDEX idx_author(author) USING INVERTED;
    Query OK, 0 rows affected (0.01 sec)

    -- Execute BUILD INDEX to add the inverted index for existing data
    mysql> BUILD INDEX idx_author ON hackernews_1m;
    Query OK, 0 rows affected (0.01 sec)
    ```
    
    为 100 万条作者记录创建增量索引仅需 1.5 秒。

    ```cmd
    mysql> SHOW ALTER TABLE COLUMN;
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+
    | JobId | TableName     | CreateTime              | FinishTime              | IndexName     | IndexId | OriginIndexId | SchemaVersion | TransactionId | State    | Msg  | Progress | Timeout |
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+
    | 10030 | hackernews_1m | 2023-02-10 19:44:12.929 | 2023-02-10 19:44:13.938 | hackernews_1m | 10031   | 10008         | 1:1994690496  | 3             | FINISHED |      | NULL     | 2592000 |
    | 10053 | hackernews_1m | 2023-02-10 19:49:32.893 | 2023-02-10 19:49:33.982 | hackernews_1m | 10054   | 10008         | 1:378856428   | 4             | FINISHED |      | NULL     | 2592000 |
    | 10076 | hackernews_1m | 2023-02-10 19:54:20.046 | 2023-02-10 19:54:21.521 | hackernews_1m | 10077   | 10008         | 1:1335127701  | 5             | FINISHED |      | NULL     | 2592000 |
    +-------+---------------+-------------------------+-------------------------+---------------+---------+---------------+---------------+---------------+----------+------+----------+---------+
    ```

    ```cmd
    mysql> SHOW BUILD INDEX ORDER BY CreateTime DESC LIMIT 1;
    +-------+---------------+---------------+----------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    | JobId | TableName     | PartitionName | AlterInvertedIndexes                               | CreateTime              | FinishTime              | TransactionId | State    | Msg  | Progress |
    +-------+---------------+---------------+----------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    | 13006 | hackernews_1m | hackernews_1m | [ADD INDEX idx_author (`author`) USING INVERTED],  | 2023-06-26 17:23:02.610 | 2023-06-26 17:23:03.755 | 3004          | FINISHED |      | NULL     |
    +-------+---------------+---------------+----------------------------------------------------+-------------------------+-------------------------+---------------+----------+------+----------+
    1 row in set (0.01 sec)
    ```

    创建索引后，字符串等价匹配的速度也明显加快。

    ```cmd
    mysql> SELECT count() FROM hackernews_1m WHERE author = 'faster';
    +---------+
    | count() |
    +---------+
    |      20 |
    +---------+
    1 row in set (0.01 sec)
    ```


