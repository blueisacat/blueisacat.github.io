---
layout: default
title: 数据表设计
parent: Doris Guides 3.0
nav_order: 1
---

# 1 概述
## 1.1 创建表
用户可以使用 `CREATE TABLE` 语句在 Doris 中创建表格。 还可以使用 `LIKE` 或 `AS` 子句从另一个表中导出表定义。

## 1.2 表名
在 Doris 中，表名默认区分大小写。 你可以在初始群集设置时配置 `lower_case_table_namest`，使其不区分大小写。 表名的默认最大长度为 64 字节，但你可以通过配置 `table_name_length_limit` 来更改。 不建议将此值设置过高。 有关创建表格的语法，请参阅 `CREATE TABLE`。

## 1.3 表属性
在 Doris `CREATE TABLE` 语句中，可以指定各种表属性。 其中，存储桶数量（buckets）、存储介质（storage_medium）、复制数量（replication_num）和冷热存储策略（storage_policy）属性适用于分区。 也就是说，一旦创建了分区，它就会有自己的属性集。 修改表属性只会影响将来创建的分区，而不会追溯到已创建的分区。 有关这些属性的更多信息，请参阅修改表属性

## 1.4 注意 
1. 不能更改数据模型，因此需要在创建表格时选择合适的数据模型。 
2. 不能修改现有分区的数据桶数量。 可以通过更换分区来更改数据桶数量。 但是，可以修改动态分区下尚未创建的分区的数据桶数量。 
3. 添加或删除 VALUE 列是一项轻量级操作，几秒钟内即可完成。 添加或删除 KEY 列或修改数据类型是一项重量级操作，完成时间取决于数据量。 在数据量较大的情况下，最好避免添加或删除 KEY 列或修改数据类型。 
4. 您可以使用分层存储将冷数据保存到硬盘或 S3 / HDFS。

# 2 数据类型

Apache Doris 支持标准 SQL 语法，使用 MySQL 网络连接协议，与 MySQL 语法协议高度兼容。 因此，在数据类型支持方面，Apache Doris 尽可能与 MySQL 相关数据类型保持一致。 

Doris 支持的数据类型列表如下：

## 2.1 数字数据类型
| 类型名称     | 存储（字节）     | 描述     |
| -------- | -------- | -------- |
| BOOLEAN | 1 | 布尔数据类型，只存储两个值： 0 表示假，1 表示真。 |
| TINYINT | 1 | 整数值，取值范围为 -128 至 127。 |
| SMALLINT | 2 | 整数值，取值范围为 -32768 至 32767。 |
| INT | 4 | 整数值，取值范围为 -2147483648 至 2147483647。 |
| BIGINT | 8 | 整数值，取值范围为 -9223372036854775808 至 9223372036854775807。 |
| LARGEINT | 16 | 整数值，取值范围为 [-2^127 + 1 至 2^127 -1]。 |
| FLOAT | 4 | 单精度浮点数，取值范围为 [-3.4 10^38 至 3.4 10^38]。 |
| DOUBLE | 8 | 双精度浮点数，取值范围为 [-1.79 10^308 至 1.79 10^308]。 |
| DECIMAL | 4/8/16 | 精确定点数，由精度（总位数）和刻度（小数点右边的位数）定义。 格式为 DECIMAL(M[,D])，其中 M 是精度，D 是刻度。 M 的范围是 [1，38]，D 的范围是 [0，精度]。 存储要求： - 0 < 精度 <= 9 时为 4 字节，- 9 < 精度 <= 18 时为 8 字节，- 18 < 精度 <= 38 时为 16 字节。 |

## 2.2 日期时间数据类型
| 类型名称     | 存储（字节）     | 描述     |
| -------- | -------- | -------- |
| DATE | 16 | DATE 包含日历年、月、日的值，支持范围为['0000-01-01', '9999-12-31']。 默认打印格式： yyyy-MM-dd'。 |
| DATETIME | 16 | 日期和时间的组合格式： datetime（[p]）。 可选参数 P 代表时间精度，取值范围为 [0,6]，最多支持 6 位小数（微秒）。 不设置时，其值为 0。支持的范围为['0000-01-01 00:00:00 [.000000]', '9999-12-31 23:59:59 [.999999]'] 。 默认打印格式： 默认打印格式：'yyyy-MM-dd HH: mm: ss. SSSSSS '. |

## 2.3 字符串数据类型
| 类型名称     | 存储（字节）     | 描述     |
| -------- | -------- | -------- |
| CHAR | M | 固定长度字符串，参数 M 指定列长度（以字符为单位）。 M 的取值范围为 1 至 255。 |
| VARCHAR | 可变长度 | 长度可变的字符串，参数 M 指定字符串的最大长度（以字符为单位）。 M 的范围是 1 到 65533。 可变长度字符串以 UTF-8 编码存储。 英文字符占 1 个字节，中文字符占 3 个字节。 |
| STRING | 可变长度 | 长度可变的字符串，默认支持 1048576 字节（1 MB），最大精度限制为 2147483643 字节（2 GB）。 字符串的大小可以通过 BE 设置 string_type_length_soft_limit_bytes 进行调整。 字符串类型只能用于值列，不能用于键列和分区桶列。 |

## 2.4 半结构化数据类型
| 类型名称     | 存储（字节）     | 描述     |
| -------- | -------- | -------- |
| ARRAY | 可变长度 | 由 T 类型元素组成的数组不能用作键列。 目前支持在具有重复和唯一模型的表中使用。 |
| MAP | 可变长度 | 由 K 和 V 类型元素组成的映射不能用作关键字列。 目前，使用重复和唯一模型的表格支持这些映射。 |
| STRUCT | 可变长度 | 由多个字段组成的结构也可以理解为多个列的集合。 它不能用作键。 目前，STRUCT 只能在重复模型表中使用。 结构体中字段的名称和数量是固定的，并且始终为空。 |
| JSON | 可变长度 | 二进制 JSON 类型，以二进制 JSON 格式存储，通过 JSON 函数访问内部 JSON 字段。 默认最多支持 1048576 字节（1MB），最大可调整为 2147483643 字节（2GB）。 该限制可通过 BE 配置参数 "jsonb_type_length_soft_limit_bytes "进行修改。 |
| VARIANT | 可变长度 | VARIANT 数据类型具有动态适应性，专为 JSON 等半结构化数据而设计。 它可以存储任何 JSON 对象，并自动将 JSON 字段分割成子列，以提高存储效率和查询性能。 长度限制和配置方法与 STRING 类型相同。 不过，VARIANT 类型只能用于值列，不能用于键列或分区/桶列。 |

## 2.5 聚合数据类型
| 类型名称     | 存储（字节）     | 描述     |
| -------- | -------- | -------- |
| HLL | 可变长度 | HLL 是 HyperLogLog 的缩写，是一种模糊重复数据删除技术。 在处理大型数据集时，它的性能优于 Count Distinct。 HLL 的错误率通常在 1%左右，有时可能达到 2%。 HLL 不能用作键列，创建表格时的聚合类型为 HLL_UNION。 用户无需指定长度或默认值，因为它会根据数据的聚合级别进行内部控制。 HLL 列只能通过 hll_union_agg、hll_raw_agg、hll_cardinality 和 hll_hash 等配套函数进行查询或使用。 |
| BITMAP | 可变长度 | BITMAP 类型可用于聚合表、唯一表或重复表。 - 在唯一表或重复表中使用时，BITMAP 必须用作非键列。 - 在聚合表中使用时，BITMAP 也必须作为非键列，并且在创建表格时必须将聚合类型设置为 BITMAP_UNION。 用户无需指定长度或默认值，因为它是根据数据的聚合级别进行内部控制的。 BITMAP 列只能通过配套函数（如 bitmap_union_count、bitmap_union、bitmap_hash 和 bitmap_hash64）来查询或使用。 |
| QUANTILE_STATE | 可变长度 | 用于计算近似量化值的类型。 加载时，它会对具有不同值的相同键进行预聚合。 当值的数量不超过 2048 个时，它会详细记录所有数据。 当数值超过 2048 个时，它会采用 TDigest 算法对数据进行聚合（聚类），并存储聚类后的中心点。 QUANTILE_STATE 不能用作键列，在创建表格时应与聚合类型 QUANTILE_UNION 搭配使用。 用户无需指定长度或默认值，因为它是根据数据的聚合级别进行内部控制的。 QUANTILE_STATE 列只能通过 QUANTILE_PERCENT、QUANTILE_UNION 和 TO_QUANTILE_STATE 等配套函数进行查询或使用。 |
| AGG_STATE | 可变长度 | 聚合函数只能与状态/合并/联合函数组合器一起使用。 AGG_STATE 不能用作键列。 创建表格时，需要同时声明聚合函数的签名。 用户无需指定长度或默认值。 实际数据存储大小取决于函数的实现。 |

## 2.6 IP 类型
| 类型名称     | 存储（字节）     | 描述     |
| -------- | -------- | -------- |
| IPv4 | 4 | 它与 ipv4_* 系列函数结合使用。 |
| IPv6 | 16 | 它与 ipv6_* 系列函数结合使用。 |

您还可以使用 SHOW DATA TYPES; 语句查看 Doris 支持的所有数据类型。

# 3 表索引
## 3.1 表索引概述

数据库索引用于加速查询。 为了加速不同的查询场景，Doris 支持各种丰富的索引。

### 3.1.1 索引类型和原则
从加速查询及其原理的角度来看，Doris 索引主要分为两类：点查询索引和跳转索引。 
* 点查询索引： 常用于加速点查询，其原理是通过索引找到满足 WHERE 条件的行，并直接读取这些行。 当满足条件的行数较少时，点查询索引非常有效。 Doris 的点查询索引包括前缀索引和反转索引。 
    * 前缀索引： Doris 根据排序键有序存储数据，每 1024 行创建一个稀疏的前缀索引。 索引中的键是当前 1024 行第一行中已排序列的值。 如果查询涉及已排序列，系统将找到相关 1024 行组的第一行，并从该行开始扫描。 
    * 倒排索引： 对于具有倒排索引的列，系统会创建一个发布列表，将每个值映射到一组行 ID。 对于相等查询，首先会从发布列表中找到行 id 集，然后直接读取这些行的数据，避免逐行扫描。 反转索引还能加速范围过滤和全文检索。 算法更加复杂，但基本原理相似。 (注意：以前的 BITMAP 索引已被功能更强大的倒置索引取代）。 
* 跳转索引： 常用于加速分析，其原理是通过索引确定不满足 WHERE 条件的数据块，并跳过这些数据块，只读取可能满足条件的数据块，然后逐行过滤，最终得到满足条件的行。 当满足条件的行数较多时，跳转索引会更加有效。 Doris 的跳转索引包括 ZoneMap 索引、BloomFilter 索引和 NGram BloomFilter 索引。 
    * ZoneMap 索引： 自动维护每个列的统计信息，记录每个数据文件（段）和数据块（页）的最大值、最小值以及是否存在 NULL 值。 对于相等查询、范围查询和 IS NULL，它可以根据最大值、最小值和是否存在 NULL 值来确定数据文件和数据块是否包含满足条件的数据。 如果不能，Doris 会跳过读取相应的文件或数据块，从而减少 IO 并加速查询。 
    * BloomFilter 索引： 将索引列的值存储在 BloomFilter 数据结构中，能以极低的存储空间快速确定某个值是否在 BloomFilter 中。 对于相等查询，如果值不在 BloomFilter 中，则可跳过相应的数据文件或数据块，从而减少 IO 并加快查询速度。 
    * NGram BloomFilter 索引： 用于加速文本 LIKE 查询。 其原理与 BloomFilter 索引类似，但不是存储原始文本值，而是对文本执行 NGram 标记化，并将每个标记存储在 BloomFilter 中。 对于 LIKE 查询，LIKE 模式也使用 NGram 进行标记化。 如果 BloomFilter 中没有任何标记，则表示相应的数据文件或数据块不符合 LIKE 条件，可以跳过。 
    
在上述索引中，前缀索引和 ZoneMap 索引是由 Doris 自动维护的内置索引，无需用户管理。 反转索引、BloomFilter 索引和 NGram BloomFilter 索引则需要用户根据实际情况手动创建和管理。

* 比较不同类型索引的特点

| 类型     | 索引     |   优势   |   局限性   |
| -------- | -------- | -------- | -------- |
| 点查询 | 前缀索引 | 内置索引，性能最佳 | 每个表只有一个前缀索引 |
| 点查询 | 倒排索引 | 支持标记化和关键字匹配、在任意列上建立索引、多条件组合和加速更多功能 | 索引存储空间大，与原始数据类似 |
| 跳转 | ZoneMap 索引 | 内置索引，索引存储空间小 | 每个表只有一个前缀索引 |
| 跳转 | BloomFilter 索引 | 比 ZoneMap 更精确，索引空间适中 | 支持的查询类型很少，只支持等价查询，不支持其他查询（不等价、范围、LIKE、MATCH） |
| 跳转 | NGram BloomFilter 索引 | 支持 LIKE 加速，索引空间适中 | 支持的查询类型很少，仅支持 LIKE 加速 |

* 用于索引加速的运算符和函数列表

| 运算符和函数 | 前缀索引 | 倒排索引 | ZoneMap 索引 | BloomFilter 索引 | NGram BloomFilter 索引 |
| -------- | -------- | -------- | -------- | -------- |-------- |
| = | YES | YES | YES | YES | NO |
| != | YES | YES | NO | NO | NO |
| IN | YES | YES | YES | YES | NO |
| NOT IN | YES | YES | NO | NO | NO |
| >, >=, <, <=, BETWEEN | YES | YES | YES | NO | NO |
| IS NULL | YES | YES | YES | NO | NO |
| IS NOT NULL | YES | YES | NO | NO | NO |
| LIKE | NO | NO | NO | NO | YES |
| MATCH, MATCH_* | NO | YES | NO | NO | NO |
| array_contains | NO | YES | NO | NO | NO |
| array_overlaps | NO | YES | NO | NO | NO |
| is_ip_address_in_range | NO | YES | NO | NO | NO |

### 3.1.2 索引设计指南
数据库表索引的设计和优化与数据分布和查询密切相关，需要根据实际情况进行测试和优化。 虽然没有 "灵丹妙药"，但 Doris 一直在努力降低使用索引的难度。 用户可以遵循以下简单指南进行索引选择和测试。 
1. 指定最常用的过滤条件作为关键字，自动创建前缀索引，因为它的过滤效果最好。 不过，每个表只能创建一个前缀索引，所以应该用于最常用的过滤条件。 
2. 对于需要过滤加速的非关键字段，首选是创建倒排索引，因为它具有广泛的适用性和多条件组合。 第二种选择包括以下两种索引： 
    1. 如果需要进行字符串 LIKE 匹配，则添加一个 NGram BloomFilter 索引。 
    2. 如果索引存储空间至关重要，则用 BloomFilter 索引取代倒置索引。 
3. 如果性能不如预期，则通过 QueryProfile 分析索引过滤的数据量和消耗的时间。 有关具体情况，请参阅每个索引的详细文档。

## 3.2 排序键和前缀索引

### 3.2.1 索引原则
Doris 存储数据的结构类似于 SSTable（Sorted String Table）。 这种结构是一种有序数据结构，可以根据一个或多个指定列进行排序和存储。 在这种数据结构中，对全部或部分排序列进行条件查询的效率非常高。

在 "聚合"、"唯一 "和 "重复 "数据模型中，底层数据存储分别根据 CREATE TABLE 语句中指定的 AGGREGATE KEY、UNIQUE KEY 和 DUPLICATE KEY 下的列进行排序。 这些键被称为排序键。 有了排序键，Doris 就可以在查询过程中通过指定排序列的条件，在不扫描整个表的情况下快速定位所需数据，从而降低搜索复杂度并加快查询速度。

根据排序键，Doris 引入了前缀索引。 前缀索引是一种稀疏索引。 表中的数据根据相应的行数形成一个逻辑数据块（数据块）。 每个逻辑数据块在前缀索引表中存储一个索引条目，索引条目的长度不超过 36 字节。 条目内容是由数据块中第一行的排序列组成的前缀。 查找前缀索引表时，它有助于确定行数据所在逻辑数据块的起始行号。 由于前缀索引相对较小，因此可以完全缓存在内存中，从而可以快速定位数据块并显著提高查询效率。

> 数据块中某一行的前 36 个字节用作该行的前缀索引。 遇到 VARCHAR 类型时，前缀索引会被直接截断。 如果第一列是 VARCHAR，即使未达到 36 字节，也会被直接截断，后续列将不包含在前缀索引中。

### 3.2.2 使用案例
前缀索引可以加快相等查询和范围查询的速度。

> 由于表的 KEY 定义是唯一的，因此一个表只能有一种前缀索引。 对于使用其他列的查询，如果不能将前缀索引作为条件，则效率可能达不到要求。 有两种解决方案： 
> * 在需要加速查询的列上创建反转索引，因为一个表可以有多个反转索引。 
> * 对于 DUPLICATE 表，可以通过创建相应的强一致性物化视图并调整列顺序来间接实现多前缀索引。 有关详细信息，请参阅查询加速/物化视图。

### 3.2.3 语法
定义前缀索引没有特定的语法。 创建表格时，表 KEY 的前 36 个字节会自动作为前缀索引。

### 3.2.4 使用示例
假设表的排序列如下，则前缀索引为：user_id（8 字节）+ age（4 字节）+ message（前缀 20 字节）。

| 列名 | 类型 |
| - | - |
| user_id | BIGINT | 
| age | INT | 
| message | VARCHAR(100) | 
| max_dwell_time | DATETIME | 
| min_dwell_time | DATETIME | 

假设表的排序列如下，则前缀索引为 user_name（20 字节）。 即使没有达到 36 字节，也会因为遇到 VARCHAR 而直接截断，并且不包括后续列。

| 列名 | 类型 |
| - | - |
| user_name | VARCHAR(20) | 
| age | INT | 
| message | VARCHAR(100) | 
| max_dwell_time | DATETIME | 
| min_dwell_time | DATETIME | 

当我们的查询条件是前缀索引的前缀时，可以大大加快查询速度。 例如，在第一个示例中，执行以下查询：

```sql
SELECT * FROM table WHERE user_id = 1829239 AND age = 20;
```

这种查询比下面的查询要有效得多：

```sql
SELECT * FROM table WHERE age = 20;
```

因此，在创建表格时选择正确的列顺序可以大大提高查询效率。

## 3.3 倒排索引
<details>
  <summary>解析器：指定标记化器</summary>
  <p>- 默认为未指定，即不进行标记化</p> 
  <p>- `english`： 英文标记化，适用于包含英文文本的栏目，使用空格和标点符号进行标记化，性能高</p> 
  <p>- `chinese`： 中文标记化，适用于主要包含中文文本的栏目，性能低于英文标记化</p>
  <p>- `unicode`: 中文标记化： 中文标记化，适用于主要包含中文文本的列，性能低于英文标记化</p>
  <p>- `unicode`： Unicode 标记化，适用于中英文混合和多语言混合文本。 它可以标记电子邮件前缀和后缀、IP 地址以及字符和数字混合字符串，还可以按字符标记中文。 
  <p>可使用 TOKENIZE SQL 函数验证标记化结果，详见以下章节。</p>
</details>
