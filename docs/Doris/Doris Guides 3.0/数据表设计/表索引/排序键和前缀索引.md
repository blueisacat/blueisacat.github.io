---
layout: default
title: 排序键和前缀索引
parent: 表索引
nav_order: 2
---

# 索引原则
Doris 存储数据的结构类似于 SSTable（Sorted String Table）。 这种结构是一种有序数据结构，可以根据一个或多个指定列进行排序和存储。 在这种数据结构中，对全部或部分排序列进行条件查询的效率非常高。

在 "聚合"、"唯一 "和 "重复 "数据模型中，底层数据存储分别根据 CREATE TABLE 语句中指定的 AGGREGATE KEY、UNIQUE KEY 和 DUPLICATE KEY 下的列进行排序。 这些键被称为排序键。 有了排序键，Doris 就可以在查询过程中通过指定排序列的条件，在不扫描整个表的情况下快速定位所需数据，从而降低搜索复杂度并加快查询速度。

根据排序键，Doris 引入了前缀索引。 前缀索引是一种稀疏索引。 表中的数据根据相应的行数形成一个逻辑数据块（数据块）。 每个逻辑数据块在前缀索引表中存储一个索引条目，索引条目的长度不超过 36 字节。 条目内容是由数据块中第一行的排序列组成的前缀。 查找前缀索引表时，它有助于确定行数据所在逻辑数据块的起始行号。 由于前缀索引相对较小，因此可以完全缓存在内存中，从而可以快速定位数据块并显著提高查询效率。

> 数据块中某一行的前 36 个字节用作该行的前缀索引。 遇到 VARCHAR 类型时，前缀索引会被直接截断。 如果第一列是 VARCHAR，即使未达到 36 字节，也会被直接截断，后续列将不包含在前缀索引中。

# 使用案例
前缀索引可以加快相等查询和范围查询的速度。

> 由于表的 KEY 定义是唯一的，因此一个表只能有一种前缀索引。 对于使用其他列的查询，如果不能将前缀索引作为条件，则效率可能达不到要求。 有两种解决方案： 
> * 在需要加速查询的列上创建反转索引，因为一个表可以有多个反转索引。 
> * 对于 DUPLICATE 表，可以通过创建相应的强一致性物化视图并调整列顺序来间接实现多前缀索引。 有关详细信息，请参阅查询加速/物化视图。

# 语法
定义前缀索引没有特定的语法。 创建表格时，表 KEY 的前 36 个字节会自动作为前缀索引。

# 使用示例
假设表的排序列如下，则前缀索引为：user_id（8 字节）+ age（4 字节）+ message（前缀 20 字节）。

| 列名 | 类型 |
| - | - |
| user_id | BIGINT | 
| age | INT | 
| message | VARCHAR(100) | 
| max_dwell_time | DATETIME | 
| min_dwell_time | DATETIME | 

假设表的排序列如下，则前缀索引为 user_name（20 字节）。 即使没有达到 36 字节，也会因为遇到 VARCHAR 而直接截断，并且不包括后续列。

| 列名 | 类型 |
| - | - |
| user_name | VARCHAR(20) | 
| age | INT | 
| message | VARCHAR(100) | 
| max_dwell_time | DATETIME | 
| min_dwell_time | DATETIME | 

当我们的查询条件是前缀索引的前缀时，可以大大加快查询速度。 例如，在第一个示例中，执行以下查询：

```sql
SELECT * FROM table WHERE user_id = 1829239 AND age = 20;
```

这种查询比下面的查询要有效得多：

```sql
SELECT * FROM table WHERE age = 20;
```

因此，在创建表格时选择正确的列顺序可以大大提高查询效率。